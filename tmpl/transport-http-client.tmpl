// Autogenerated code, do not change directly.
// To make changes to this file, please modify the templates at
// go-kit-middlewarer/tmpl/*.tmpl

package http

import (
	"io"
	"strings"
	"net/url"

	{{range .ExtraImports}}
	{{.}}{{end}}

	kitendpoint "github.com/go-kit/kit/endpoint"
	httptransport "github.com/go-kit/kit/transport/http"
	kitloadbalancer "github.com/go-kit/kit/loadbalancer"

	"{{.EndpointPackage}}"
	{{.BasePackageImport}}
)

// HTTPClientLayer is a function that takes an address and path string, so you
// can have extra information, then it should return a
// github.com/go-kit/kit/transport/http.ClientOption to wrap around the
// endpoint.
type HTTPClientLayer func( addr, path string ) kitendpoint.Middleware

// httpFactory will take a path, encoding function, decoding function, and a
// slice of github.com/go-kit/kit/transport/http.ClientOption(s)
func httpFactory( path string, enc httptransport.EncodeRequestFunc, dec httptransport.DecodeResponseFunc, wrappers []kitendpoint.Middleware, options []httptransport.ClientOption ) kitloadbalancer.Factory {
	return func(addr string) (kitendpoint.Endpoint, io.Closer, error) {
		// first we need to ensure that the address given (addr) is valid.
		if !strings.HasPrefix(addr, "http") {
			addr = "http://" + addr
		}
		uri, err := url.Parse(addr)
		if err != nil {
			panic(err)
		}

		p, err := url.Parse(path)
		if err != nil {
			panic(err)
		}

		uri = uri.ResolveReference(p)

		cli := httptransport.NewClient(
			"GET", uri, enc, dec, options...
		)

		ep := cli.Endpoint()
		for _, w := range wrappers {
			ep = w(ep)
		}

		return ep, nil, nil
	}
}

// mapHTTPClientLayersToClientOptions is a helper function to quickly convert
// a bunch of HTTPClientLayer to a slice of Middlewares
func mapHTTPClientLayersToClientOptions( clientLayers []HTTPClientLayer, addr, path string ) []kitendpoint.Middleware {
	var result []kitendpoint.Middleware
	for _, l := range clientLayers {
		result = append(result, l(addr,path))
	}
	return result
}

// NewHTTPClient creates a new {{.InterfaceName}} that will call methods at
// the given address provided by the addr string.  This function takes a series
// of HTTPClientLayer(s) that will be applied to the client before the
// subsequent method call.
func NewHTTPClient( addr string, {{range .ExtraInterfaces}}{{.Name}} {{.Type}}, {{end}}wrappers ...HTTPClientLayer ) {{.BasePackageName}}.{{.InterfaceName}} {
	var (
		{{range .Methods}}
		{{.MethodNameLcase}}Endpoint, _, _ = httpFactory( {{.EndpointPackageName}}.Path{{.MethodName}}, encode{{.MethodName}}Request, decode{{.MethodName}}Response, mapHTTPClientLayersToClientOptions( wrappers, addr, {{.EndpointPackageName}}.Path{{.MethodName}}), nil)(addr){{end}}
	)

	return &client{{.InterfaceName}} {
		{{range .ExtraInterfaces}}{{.PublicName}}: {{.Name}},
		{{end}}
		{{range .Methods}}
		{{.MethodNameLcase}}Endpoint: {{.MethodNameLcase}}Endpoint,{{end}}
	}
}

// NewHTTPClientWithOptions creates a new {{.InterfaceName}} that will call methods at
// the given address provided by the addr string.  This function takes a series
// of HTTPClientLayer(s) that will be applied to the client before the
// subsequent method call.
func NewHTTPClientWithOptions( addr string, {{range .ExtraInterfaces}}{{.Name}} {{.Type}}, {{end}}wrappers []HTTPClientLayer, options []httptransport.ClientOption ) {{.BasePackageName}}.{{.InterfaceName}} {
	var (
		{{range .Methods}}
		{{.MethodNameLcase}}Endpoint, _, _ = httpFactory( {{.EndpointPackageName}}.Path{{.MethodName}}, encode{{.MethodName}}Request, decode{{.MethodName}}Response, mapHTTPClientLayersToClientOptions( wrappers, addr, {{.EndpointPackageName}}.Path{{.MethodName}}), options)(addr){{end}}
	)

	return &client{{.InterfaceName}} {
		{{range .ExtraInterfaces}}{{.PublicName}}: {{.Name}},
		{{end}}
		{{range .Methods}}
		{{.MethodNameLcase}}Endpoint: {{.MethodNameLcase}}Endpoint,{{end}}
	}
}




















